# SM2 密码算法完整实现与安全研究项目

## 1. 项目背景与简介

本项目是基于 Python 的 SM2 椭圆曲线公钥密码算法的完整实现与安全研究平台。SM2 是由中国国家密码管理局发布的国家商用密码标准，广泛应用于数字签名、密钥交换和公钥加密等领域。与 RSA 等算法相比，SM2 在提供同等安全强度的情况下，具有更短的密钥和更快的运算速度。

本项目不仅实现了标准的 SM2 算法，还深入研究了椭圆曲线密码学的安全问题，包括算法优化、安全漏洞分析和攻击技术演示。

### 1.1 核心功能模块

1. **SM2 基础实现** - 标准的 SM2 数字签名和公钥加密
2. **SM2 性能优化** - 多种优化技术提升算法性能
3. **类 PGP 混合加密协议** - 结合 SM2 和 SM4 的安全通信方案
4. **签名算法误用攻击** - 演示随机数重用的安全风险
5. **ECDSA 签名伪造** - 展示椭圆曲线签名的安全特性

### 1.2 教育与研究价值

本项目具有重要的教育和研究价值：
- **密码学教学**：通过实际代码理解椭圆曲线密码学原理
- **安全研究**：分析数字签名算法的潜在安全问题
- **性能优化**：探索椭圆曲线运算的高效实现方法
- **安全意识**：通过攻击演示强调密码学实现的重要性

## 2. 项目结构

```
/
├── SM2_IMPL/                           # SM2 核心算法实现
│   ├── SM2_Enc.py                      # SM2 公钥加密/解密
│   ├── SM2_Sign.py                     # SM2 数字签名/验证
│   └── sm2_utils.py                    # SM2 共享工具函数
│
├── SM2_OPTIMIZATION/                   # SM2 性能优化实现
│   ├── optimized_sm2_utils.py         # 优化的椭圆曲线运算
│   ├── optimized_sm2_sign.py          # 优化的数字签名
│   └── optimized_sm2_enc.py           # 优化的公钥加密
│
├── SM2_PGP/                           # 类 PGP 混合加密协议
│   └── SM2_PGP.py                     # SM2+SM4 混合加密
│
├── SIGNATURE_MISUSE_POC/              # 签名算法误用攻击演示
│   ├── README.md                      # 攻击原理说明
│   ├── k_reuse_attack.py             # k 重用攻击实现
│   └── sm2_utils.py                   # 基础工具函数
│
├── SATOSHI_SIGNATURE_FORGE/           # ECDSA 签名伪造演示
│   ├── README.md                      # 伪造攻击说明
│   └── satoshi_forge.py              # 比特币签名伪造
│
├── venv/                              # Python 虚拟环境
├── requirements.txt                    # 项目依赖
├── test_all.sh                        # 一键测试脚本
└── README.md                          # 本文档
```

## 3. 算法原理与实现详解

### 3.1 深入数学原理：椭圆曲线密码学 (ECC)

SM2 的安全性根植于椭圆曲线密码学 (Elliptic Curve Cryptography, ECC) 的数学基础。其核心是利用定义在有限域上的椭圆曲线所构成的阿贝尔群的特性。

#### 3.1.1 有限域上的椭圆曲线

SM2 采用的曲线定义在素数有限域 `F_p` 上，其曲线方程为：
**y² ≡ x³ + ax + b (mod p)**

- **素数域 `F_p`**: 这是一个包含 `{0, 1, ..., p-1}` 共 `p` 个元素的集合，其中 `p` 是一个大素数。所有的运算（加、减、乘、逆）都在模 `p` 的意义下进行。这使得曲线上的点坐标是有限且离散的。
- **曲线参数 `a`, `b`**: 定义了曲线的具体形状。为了避免奇异点（导致运算无定义），参数必须满足 `4a³ + 27b² ≠ 0 (mod p)`。
- **曲线上的点**: 满足上述方程的坐标对 `(x, y)`，以及一个特殊的“无穷远点” `O`。

#### 3.1.2 椭圆曲线的群论基础

椭圆曲线上的所有点（包括无穷远点 `O`）与一个定义的“点加”运算构成了一个阿贝尔群（交换群）。

- **单位元**: 无穷远点 `O` 是群的单位元，类似于整数加法中的 0。对于任意点 `P`，有 `P + O = P`。

- **逆元**: 对于任意点 `P = (x, y)`，其逆元是 `-P = (x, -y mod p)`。它们的和为无穷远点 `P + (-P) = O`。在几何上，`-P` 是 `P` 关于 x 轴的对称点。

- **点加运算 (P + Q)**:
  - **几何定义**: 在曲线上取两点 `P` 和 `Q`，画一条直线穿过它们，这条直线会与曲线交于第三点 `R'`。`R'` 关于 x 轴的对称点 `R` 就是 `P+Q` 的结果。
  - **代数定义**:
    - 若 `P(x₁, y₁) ≠ Q(x₂, y₂)`:
      - 斜率 `λ = (y₂ - y₁) * (x₂ - x₁)⁻¹ mod p`
      - `x₃ = (λ² - x₁ - x₂) mod p`
      - `y₃ = (λ(x₁ - x₃) - y₁) mod p`
    - `P+Q` 的结果为 `(x₃, y₃)`。

- **点倍运算 (2P)**:
  - **几何定义**: 当 `P = Q` 时，点加运算变为点倍运算。此时，画一条经过 `P` 点的切线，该切线与曲线交于另一点 `R'`，`R'` 的对称点 `R` 就是 `2P` 的结果。
  - **代数定义**:
    - 斜率 `λ = (3x₁² + a) * (2y₁)⁻¹ mod p`
    - `x₃ = (λ² - 2x₁) mod p`
    - `y₃ = (λ(x₁ - x₃) - y₁) mod p`

#### 3.1.3 标量乘法与椭圆曲线离散对数问题 (ECDLP)

- **标量乘法 (Scalar Multiplication)**:
  计算 `Q = k * P`，其中 `k` 是一个整数（标量），`P` 是曲线上的一个点。这个运算本质上是 `k` 个 `P` 相加，即 `P + P + ... + P`。通过高效的“倍加算法”（Binary Method）可以快速计算，其时间复杂度为 `O(log k)`。
  **这是 ECC 中正向计算的基础，易于执行。**

- **椭圆曲线离散对数问题 (ECDLP)**:
  这是 ECC 安全性的基石。给定基点 `G` 和公钥点 `P_A`，且已知 `P_A = d_A * G`，在经典计算机上，想要从 `P_A` 和 `G` 计算出私钥 `d_A` 是极其困难的。这个问题被称为椭圆曲线离散对数问题。
  **这是 ECC 中反向计算的难题，保证了私钥的安全。**

#### 3.1.4 密钥对生成

1.  **选择基点 `G`**: `G` 是一个公开的、阶为 `n` 的点（`n` 是一个大素数，`n*G = O`）。
2.  **生成私钥 `d_A`**: 从 `[1, n-1]` 范围内随机选择一个整数作为私钥。
3.  **计算公钥 `P_A`**: 通过标量乘法计算 `P_A = d_A * G`。

公钥 `P_A` 可以公开，而私钥 `d_A` 必须保密。从公钥反推私钥的难度，就是 ECDLP 的难度。

### 3.2 SM2 数字签名

#### 3.2.1 实现思路

`SM2_IMPL/SM2_Sign.py` 实现了 SM2 数字签名的核心逻辑。
1.  **密钥生成**: 使用 `sm2_utils.py` 中的 `scalar_mult` 函数，通过私钥 `d` 和基点 `G` 计算出公钥 `P = d * G`。
2.  **Z值计算**: `get_za` 函数将用户ID和公钥参数拼接后，使用 SM3 哈希生成一个与用户身份绑定的唯一值 `Z_A`，用于防止身份伪造。
3.  **签名生成**: `sign` 函数严格按照国密标准执行：
    -   计算 `M' = Z_A || Message` 的哈希 `e`。
    -   生成一个安全的随机数 `k`。
    -   计算 `(x₁, y₁) = k * G`。
    -   计算 `r = (e + x₁) mod n`。
    -   计算 `s = ((1 + d_A)⁻¹ * (k - r * d_A)) mod n`。
4.  **签名验证**: `verify` 函数执行验证流程：
    -   计算 `t = (r + s) mod n`。
    -   计算 `(x₁, y₁) = s * G + t * P_A`。
    -   计算 `R = (e + x₁) mod n`，并检查 `R` 是否等于 `r`。

#### 3.2.2 数学原理：验证逻辑的一致性

验证的核心是检查 `r' == r`。我们将验证过程中的 `(x₁, y₁)` 展开：
`(x₁, y₁) = s * G + t * P_A`
将 `t = r + s` 和 `P_A = d_A * G` 代入：
`(x₁, y₁) = s * G + (r + s) * d_A * G = (s + r*d_A + s*d_A) * G = (s(1+d_A) + r*d_A) * G`

现在，我们将签名 `s` 的定义 `s = (1+d_A)⁻¹(k - r*d_A)` 代入 `s(1+d_A)`：
`s(1+d_A) = k - r*d_A`
代入上式：
`(x₁, y₁) = (k - r*d_A + r*d_A) * G = k * G`
这证明了如果签名是正确的，验证过程中计算出的点 `(x₁, y₁)` 正是签名时由 `k*G` 产生的点。因此，`r' = (e + x₁) mod n` 必然等于原始的 `r`。

### 3.3 SM2 公钥加密

#### 3.3.1 实现思路

`SM2_IMPL/SM2_Enc.py` 实现了 SM2 的公钥加解密。
1.  **加密**: `encrypt` 函数执行以下步骤：
    -   生成一个随机数 `k`。
    -   计算 `C₁ = k * G`，这是一个椭圆曲线点，编码后作为密文的一部分。
    -   计算共享密钥点 `S = k * P_B`，其中 `P_B` 是接收者的公钥。
    -   使用密钥派生函数 `kdf` 从 `S` 的坐标中派生出密钥流 `t`。
    -   计算 `C₂ = M ⊕ t`，即消息与密钥流的异或。
    -   计算 `C₃ = Hash(x₂ || M || y₂)`，作为消息认证码（MAC）。
    -   输出密文 `(C₁, C₂, C₃)`。
2.  **解密**: `decrypt` 函数执行逆向过程：
    -   从 `C₁` 中恢复出点。
    -   计算共享密钥点 `S = d_B * C₁`，其中 `d_B` 是接收者的私钥。
    -   使用 `kdf` 派生出相同的密钥流 `t`。
    -   计算 `M' = C₂ ⊕ t` 恢复消息。
    -   计算 `C₃' = Hash(x₂ || M' || y₂)`，并与传入的 `C₃` 比较，以验证消息完整性。

#### 3.3.2 数学原理：共享密钥的构建

加密的核心是构建一个临时的、只有通信双方知道的共享秘密。
- **加密方**: 计算 `S = k * P_B = k * (d_B * G)`
- **解密方**: 计算 `S = d_B * C₁ = d_B * (k * G)`
由于标量乘法满足结合律 `k * d_B * G = d_B * k * G`，双方可以独立计算出完全相同的共享密钥点 `S`，而第三方无法得知。这个共享秘密 `S` 的坐标随后被用于密钥派生函数（KDF），生成用于异或加密的密钥流 `t`。

### 3.4 SM2 性能优化

#### 3.4.1 实现思路

`SM2_OPTIMIZATION/` 目录下的脚本旨在提升 SM2 的运算效率。
- **`optimized_sm2_utils.py`**:
  - **窗口化标量乘法 (`scalar_mult_windowed`)**: 通过 `precompute_table` 函数预先计算基点 `G` 的少量倍数并存储。在计算 `k*G` 时，将 `k` 分成多个“窗口”，每次处理一个窗口的比特位，通过查表和少量点加法来代替大量的逐比特点加，从而减少运算次数。
  - **蒙哥马利梯 (`scalar_mult_montgomery_ladder`)**: 实现了一种特殊的标量乘法，其操作序列（点加和点倍）不依赖于密钥 `k` 的具体比特位是0还是1。这使得功耗分析等侧信道攻击难以奏效。
- **`optimized_sm2_sign.py`**:
  - 使用了 `scalar_mult_windowed` 来加速签名和验签中的标量乘法。
  - 实现了确定性 `k` 生成 (`_generate_deterministic_k`)，基于消息和私钥的哈希来生成 `k`，避免了对高质量随机数的依赖，从根本上杜绝了 k-Reuse 攻击。
- **`optimized_sm2_enc.py`**:
  - **并行 KDF (`kdf_optimized`)**: 当需要派生的密钥长度超过哈希长度时，需要多轮哈希。通过 `ThreadPoolExecutor` 将这些哈希计算并行化，可以有效利用多核 CPU 资源。
  - **分块加解密**: `encrypt_large_data` 和 `decrypt_large_data` 函数将大文件切分成小块，对每块独立进行 SM2 加密，适用于处理大文件。

### 3.5 类 PGP 混合加密协议

#### 3.5.1 实现思路

`SM2_PGP/SM2_PGP.py` 结合了非对称加密（SM2）和对称加密（SM4）的优点，实现了高效、安全的数据封装。
1.  **生成会话密钥**: 首先，生成一个一次性的、高强度的随机密钥，用于 SM4 对称加密。
2.  **数据签名与加密**:
    -   发送方用自己的 SM2 私钥对 `(消息)` 进行签名，保证来源真实性和完整性。
    -   用 SM4 会话密钥加密 `(签名 || 消息)`。对称加密速度远快于非对称加密，适合处理大块数据。
3.  **密钥封装**:
    -   用接收方的 SM2 公钥加密 SM4 会话密钥。非对称加密用于安全地交换密钥。
4.  **组合与传输**: `最终密文 = (加密的会话密钥) + (SM4 加密的数据)`。
5.  **解密与验证**: 接收方执行逆向操作，先用自己的 SM2 私钥解密出会话密钥，再用会话密钥解密数据，最后用发送方的公钥验证签名。

### 3.6 签名算法误用攻击 (k-Reuse)

#### 3.6.1 数学推导

假设签名者使用了相同的随机数 `k` 对两条不同的消息 `M₁` 和 `M₂` 进行了签名，产生两个签名 `(r₁, s₁)` 和 `(r₂, s₂)`。

根据签名公式 `s = ((1 + d)⁻¹ * (k - r * d)) mod n`，可得：
1.  `s₁ * (1 + d) = k - r₁ * d  =>  k = s₁ + (s₁ + r₁) * d`
2.  `s₂ * (1 + d) = k - r₂ * d  =>  k = s₂ + (s₂ + r₂) * d`

由于 `k` 相同，两式相等：
`s₁ + (s₁ + r₁) * d = s₂ + (s₂ + r₂) * d`
移项整理可解出私钥 `d`：
`s₁ - s₂ = (s₂ + r₂ - s₁ - r₁) * d`
`d = (s₁ - s₂) * (s₂ + r₂ - s₁ - r₁)⁻¹ mod n`

#### 3.6.2 实现思路

`SIGNATURE_MISUSE_POC/k_reuse_attack.py` 脚本模拟了此攻击：
1.  `faulty_sign` 函数被设计为接受一个固定的 `k` 作为参数，模拟了随机数生成器的缺陷。
2.  脚本使用此函数对两条不同消息进行签名，获得 `(r₁, s₁)` 和 `(r₂, s₂)`。
3.  `k_reuse_attack` 函数严格按照上述推导公式，仅利用这两个签名就计算出了私钥 `d`。
4.  最后，将计算出的私钥与原始私钥比较，验证攻击成功。

### 3.7 ECDSA 签名伪造

#### 3.7.1 数学推导

ECDSA（比特币使用的签名算法）的签名公式与 SM2 不同：`s = k⁻¹ * (z + r * d) mod n`，其中 `z` 是消息哈希。
如果 `k` 泄露，私钥 `d` 的恢复过程如下：
`s * k = z + r * d`
`r * d = s * k - z`
`d = r⁻¹ * (s * k - z) mod n`

#### 3.7.2 实现思路

`SATOSHI_SIGNATURE_FORGE/satoshi_forge.py` 演示了这一过程：
1.  **设定场景**: 脚本使用了比特币 secp256k1 曲线参数，并设定了一个已知的测试私钥 `TEST_PRIVATE_KEY`。
2.  **生成测试数据**: 为了确保逻辑正确，我们首先用已知的私钥和 `k` 生成一个合法的签名 `(r, s)`。
3.  **模拟攻击**: `recover_private_key` 函数接收这个签名 `(r, s)`、消息哈希 `z` 和“泄露的”`k`，然后应用上述推导公式计算出私钥 `d`。
4.  **伪造签名**: 脚本使用恢复出的私钥 `d`，对一条全新的消息（"Satoshi was here..."）进行签名，生成一个伪造的签名。
5.  **验证**: 最后，使用原始的公钥验证这个伪造的签名。验证通过，证明了攻击的有效性，即只要 `k` 泄露一次，私钥就永久泄露，攻击者可以冒充身份签署任何消息。

## 4. 如何安装和运行

### 4.1 环境要求
- Python 3.8+
- `pip` 包管理器

### 4.2 安装步骤

1.  **克隆仓库**
    ```bash
    git clone <your-repo-url>
    cd <project-directory>
    ```

2.  **创建并激活 Python 虚拟环境**
    ```bash
    # 创建虚拟环境
    python3 -m venv venv
    # 激活虚拟环境 (Linux/macOS)
    source venv/bin/activate
    # 激活虚拟环境 (Windows)
    # venv\Scripts\activate
    ```

3.  **安装依赖**
    ```bash
    pip install -r requirements.txt
    ```

### 4.3 运行测试

- **运行所有测试**:
  ```bash
  # 首先赋予脚本执行权限
  chmod +x test_all.sh
  # 运行测试
  ./test_all.sh
  ```

- **单独运行模块**:
  ```bash
  # 运行基础签名测试
  python SM2_IMPL/SM2_Sign.py
  
  # 运行优化性能测试
  python SM2_OPTIMIZATION/optimized_sm2_sign.py
  
  # 运行 k-reuse 攻击演示
  python SIGNATURE_MISUSE_POC/k_reuse_attack.py
  
  # 运行签名伪造演示
  python SATOSHI_SIGNATURE_FORGE/satoshi_forge.py
  ```

## 5. 总结

本项目不仅完整实现了 SM2 密码算法的核心功能，还深入探讨了其性能优化和安全问题。通过理论分析和代码实践，本项目为学习和研究椭圆曲线密码学提供了一个全面的平台。


## 4. 如何安装和运行

### 4.1 环境要求
- Python 3.8+
- `pip` 包管理器

### 4.2 安装步骤

1.  **克隆仓库**
    ```bash
    git clone <your-repo-url>
    cd <project-directory>
    ```

2.  **创建并激活 Python 虚拟环境**
    ```bash
    # 创建虚拟环境
    python3 -m venv venv
    # 激活虚拟环境 (Linux/macOS)
    source venv/bin/activate
    # 激活虚拟环境 (Windows)
    # venv\Scripts\activate
    ```

3.  **安装依赖**
    ```bash
    pip install -r requirements.txt
    ```

### 4.3 运行测试

- **运行所有测试**:
  ```bash
  # 首先赋予脚本执行权限
  chmod +x test_all.sh
  # 运行测试
  ./test_all.sh
  ```

- **单独运行模块**:
  ```bash
  # 运行基础签名测试
  python SM2_IMPL/SM2_Sign.py
  
  # 运行优化性能测试
  python SM2_OPTIMIZATION/optimized_sm2_sign.py
  
  # 运行 k-reuse 攻击演示
  python SIGNATURE_MISUSE_POC/k_reuse_attack.py
  
  # 运行签名伪造演示
  python SATOSHI_SIGNATURE_FORGE/satoshi_forge.py
  ```

## 5. 总结

本项目不仅完整实现了 SM2 密码算法的核心功能，还深入探讨了其性能优化和安全问题。通过理论分析和代码实践，本项目为学习和研究椭圆曲线密码学提供了一个全面的平台。


## 4. 实现思路与设计

- **模块化**: 将 SM2 的基础运算、签名、加密以及 PGP 协议分别实现在不同的模块中，结构清晰，易于维护和扩展。
- **代码复用**: 在 `sm2_utils.py` 中提供共享的曲线参数和点运算函数，避免了在签名和加密模块中重复定义。
- **依赖管理**: 使用 `gmssl` 库提供的 SM3 哈希算法和 SM4 对称加密算法，使用 `gmpy2` 库进行高效的模逆运算。所有依赖项均在 `requirements.txt` 中明确列出。
- **可读性与规范**: 代码遵循 PEP 8 规范，添加了详细的文档字符串和类型提示，使代码易于理解。
- **自动化测试**: 提供了 `test_all.sh` 脚本，可以一键运行所有模块的测试用例，确保代码的正确性。

## 5. 如何安装和运行

### 5.1 环境要求
- Python 3.8+
- `pip` 包管理器

### 5.2 安装步骤

1.  **克隆仓库**
    ```bash
    git clone <your-repo-url>
    cd <project-directory>
    ```

2.  **创建并激活 Python 虚拟环境**
    ```bash
    # 创建虚拟环境
    python3 -m venv venv
    # 激活虚拟环境 (Linux/macOS)
    source venv/bin/activate
    # 激活虚拟环境 (Windows)
    # venv\Scripts\activate
    ```

3.  **安装依赖**
    ```bash
    pip install -r requirements.txt
    ```

### 5.3 运行测试

- **运行所有测试**:
  ```bash
  # 首先赋予脚本执行权限
  chmod +x test_all.sh
  # 运行测试
  ./test_all.sh
  ```

- **单独运行模块**:
  ```bash
  # 运行签名测试
  python SM2_IMPL/SM2_Sign.py
  
  # 运行加密测试
  python SM2_IMPL/SM2_Enc.py
  
  # 运行 PGP 协议测试
  python SM2_PGP/SM2_PGP.py
  ```

## 6. 总结

本项目完整且正确地实现了 SM2 密码算法的核心功能，并在此基础上构建了一个实用的混合加密协议。